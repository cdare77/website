<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <!-- Bootstrap 4.1 -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <!-- actual stylesheet -->
  <link href="aes.css" rel="stylesheet" type="text/css">
  <!-- google fonts -->
  <link href="https://fonts.googleapis.com/css?family=Quattrocento|Aldrich|Special+Elite" rel="stylesheet">
  <!-- jquery -->
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js'></script>
  <!-- MathJax -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML' async></script>
  <!-- Code Prettify -->
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=sunburst"></script>
  <!-- My scripts -->
  <script src="../footerscript.js"></script>
  <script src="../tooltip.js"></script>
  <script src="../showbutton.js"></script>
</head>
<body data-spy="scroll" data-target="#contentNav" data-offset="15" style="position: relative;">

<!-- Navigation bar -->


<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-brand" href="#">Chris Dare</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item">
        <a class="nav-link" href="../homepage.html">Home<span class="sr-only">(current)</span></a>
      </li>
      <!-- Blog Dropdown -->
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="../blogpage.html" id="navbarDropdownBlogLink"  aria-haspopup="true" aria-expanded="false">Blog<span class="sr-only">(current)</span></a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdownBlogLink">
          <a class="dropdown-item" href="../blogposts/manifoldsparti.html">Manifolds: Part I</a>
          <a class="dropdown-item" href="#">Post2</a>
        </div>
      </li>
      <!-- Code Dropdown -->
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="../codepage.html" id="navbarDropdownCodeLink" aria-haspopup="true" aria-expanded="false" style="font-family: 'Courier New', Courier;">
          Code
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdownCodeLink">
          <a class="dropdown-item active" href="#" style="font-family: 'Courier New', Courier;">AES</a>
          <a class="dropdown-item" href="#" style="font-family: 'Courier New', Courier;">Code2</a>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="../mymusicpage.html">My Music</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="../photospage.html">Photos</a>
      </li>
    </ul>
  </div>
</nav>

<!-- webpage header -->

<div class="jumbotron vertical-center header">
  <h1 style="font-family:'Special Elite', cursive;">AES</h1>
  <h5 style="font-family:'Special Elite', cursive;">Advanced Encryption Standard (FIPS 197)</h5>
</div>


<div class="row">

  <!-- side navbar -->
  <div class="col-2">
    <nav id="content-nav" class="navbar navbar-light bg-light">
      <nav class="nav nav-pills flex-column">
        <a class="nav-link" href="#item-1">Introduction To Ciphers</a>
        <a class="nav-link" href="#item-2">Why AES?</a>
        <a class="nav-link" href="#item-3">The Cipher</a>
        <nav class="nav nav-pills flex-column">
          <a class="nav-link ml-3 my-1" href="#item-3-1">Key Schedule</a>
          <a class="nav-link ml-3 my-1" href="#item-3-2"><code>SubBytes()</code></a>
          <a class="nav-link ml-3 my-1" href="#item-3-3"><code>ShiftRows()</code></a>
          <a class="nav-link ml-3 my-1" href="#item-3-4"><code>MixColumns()</code></a>
          <a class="nav-link ml-3 my-1" href="#item-3-5"><code>AddRoundKey()</code></a>
        </nav>
        <a class="nav-link" href="#item-4">Encryption Code</a>
        <a class="nav-link" href="#item-5">Additional Content: \(GF(2^8)\)</a>
        <a class="nav-link" href="#item-6">Additional Content: Decryption</a>
      </nav>
    </nav>
  </div>

  <!-- content -->
  <div class="col-10">
      <h4 id="item-1">Introduction to Ciphers</h4>
      <br>
      <p>In today's world there is a massive effort to secure data that we wish private - and for good reason. 
Clearly, things like our social-security number, credit card information, and passwords should be hidden from anyone who could use them maliciously, but seldom do we ask ourselves how this data is <em>actually</em> hidden. 
Clearly the answer is <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Translating data or plain text into a masked cipher text through the use of a cipher">encryption</a>, or else I wouldn't be spending my Tuesday evening writing a post about the U.S. government's current endorsed encryption (and thus most of the commercial industry as well since many government contractors feel no need to write separate software for the public and private sectors).
 For those who don't know what a block <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="An algorithm used to mask data in a covert manner">cipher</a> is, a good analogy would be an old safe: our cipher is the safe itself, our data is whatever valuable you intend to put in the safe, and our key is also called a key (but is really just a big number of our choosing used for calculations).</p>
      <img src="../images/ciphersafe.png" style="width: 1000px; height: auto;">
      <h4 id="item-2">Why AES?</h4>
      <br>
      <p>Great question. You'd probably need a masters in computer science or mathematics with respect to algebra to get a full answer.
The simple answer is that it remains very resiliant under years of scrutiny without sacrificing much speed. 
Note that this does not mean that it is an efficient cipher (see <a href="#">PRINCE</a>); nonetheless, would you rather keep your money in a national bank that probably takes half-an-hour to withdraw from or in a safe under your bed?</p>
      <p> For those interested in the security aspect, the previous analogy of the safe breaks down when it comes to the motive of the hackers/thieves.
 Just as a thief is interested in the money inside a safe, one would expect that the motive of a hacker is to steal the passwords / sensitive information; however, it is truly the motive of a hacker to retrieve the key (I'm interchanging hacker and cryptanalyst a bit loosely -- in reality I think most hackers would be perfectly happy with a few hundred passwords).
Therefore, the objective of a cipher (i.e. our safe) is to make it as hard as possible to retrieve the safe's key. </p>

      <p> Clearly, as all computer information is stored in binary, our key is just a fixed number of bits (128, 192, or 256 for AES); thus, for every bit that we add, our <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The abstract set / collection  of all possible keys">key space</a> effectively doubles.
In order to break a cipher, one must find some sort of algorithm which produces a key with greater efficiency than a <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Trying every key possible to match a plaintext (unencrypted) / ciphertext (encrypted) pair">brute-force</a> solution. 
Though I have not gone into the details of AES yet, this is the rational behind adding extra rounds to larger key sizes.
There are essentially no efficient attacks on AES itself (<a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Attacking the underlying hardware or operating system to bypass an algorithm">side-channel attacks</a> are irrelevant, and a biclique attack only has theoretical improvement from \(2^{128} \) to \( 2^{126} \)) that are a significant improvement over brute-force.
While there are currently other ciphers just as strong as AES (i.e. Serpent and Twofish), the attention given to AES over the past two decades has allowed for speedups and security updates to patch commonly-known side-channel attacks.
      </p>
      <br>
      <h4 id="item-3">The Cipher</h4>
      <br>
      <p>Now that you have all the background that you probably didn't ask for in the first place, it's time to discuss the actual algorithm of AES.
AES is what cryptographers call a <a style="color: #00c624" data-toggle="tooltip" title data-original-title="A cipher who's algorithm is based off translating a fixed number of bits, then swapping the order of the bits">Substitution-Permutation Network</a> (SPN): every round or iteration of the algorithm takes our chunk of data, breaks it into smaller chunks that are fed through a substitution box and thereafter swapped around according to some sort of permutation.
 </p>
 <p> In order to truly understand what is going on in AES, the reader would first have to become fimiliar with the basics of ring theory and Galois fields (also referred to as finite fields); I will leave <a class="popLink" href="#item-5">a section</a> at the end to cover these things for the reader who doesn't spend enough time outside. In the meantime, I will continue along with the algorithm.
 </p>
 <p> As I briefly mentioned in an aside earlier, the AES algorithm is somewhat dependent on key-length which is either 128 bits, 192 bits, or 256 bits (note, however, that the size of the data we wish to encrypt is fixed at 128 bytes). The reason I say somewhat is because AES is essentially a collection of functions ( <code>SubBytes()</code>, <code>ShiftRows()</code>, <code>MixColumns</code>, and <code>AddRoundKey()</code> ) that are repeatedly executed; each iteration of these functions is referred to as a <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="A single repetition/iteration of an iterative algorithm">round</a>. Each of AES-128, AES-192, and AES-256 execute the same round, however the number of rounds differs for each variant: AES-128 executes 10 rounds, AES-192 executes 12 rounds, and AES-256 executes 14 rounds. Going back to the rational of more rounds for longer keys from above, the 14 rounds extends the computation time of most <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Decoding encrypted text without the key">crypanalysis</a> just enough so that it takes as long as a brute-force solution. With that said, here's a breakdown of the functions that are executed in each round of the algorithm:
</p>
    <br>
    <h5 id="item-3-1">Key Schedule</h5>
    <br>
    <p> So by this time, you're likely wondering how the key acutally fits into the cipher - is there some sort of lock hidden in the code where the key mysteriously fits in, maybe some hash function that checks authenticity? Nope, not really. As I briefly touched upon earlier, the key is basically a large number used for arithmetic operations in \(GF(2^8)\); but even that isn't entirely true, as the key itself is only used in the first round for <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The process of adding round keys before and after the encryption to expand the possible key space">key-whitening</a>. For later operations, the key is actually used to generate what are called <a style="color: #00c624" data-toggle="tooltip" title data-original-title="Word-sized (4 byte) chunks that are generated from the original key in an algorithm called a Key Schedule">round keys</a> in a <a style="color: #00c624" data-toggle="tooltip" title data-original-title="An algorithm almost always independent of the cipher for generating unique round keys for each round">key schudule</a>; many ciphers utilize the concept of a key schedule, as it greatly improves upon the security of a key. For example, if a cryptanalyst were to gain access to one of our round keys through extensive attacks, the strength of our key schedule would determine whether that  is enough information to compute the original key (in the case of AES, it does not but allows the cryptanalyst to gain access to other round keys which collectively can accomplish the task).
    </p>
    <p> The AES key schedule is broken down into two subroutines, <code>SubWord()</code> and <code>RotWord</code>, which are added in \(GF(2^8)\) to a round constant. The algorithm makes its so that, depending on the length of the key, the previous round is added to the current round's key so that, as we continue along the key schedule, we experience a similar <a class="popLink" href="https://en.wikipedia.org/wiki/Avalanche_effect">avalanche effect</a> to that of SHA. Implementing the subroutines is incredibly straightforward: <code>RotWord()</code> cyclically rotates the bytes of the current round key (much like a wrap-around right-shift), and <code>SubWord()</code> simply breaks the round key up into individual bytes and sends them through the SBox (which is explained in next section). Here is the code for each:
    </p>
    <div class="showbar">
      <button type="button" id="showRotSubPyBut" onclick="showbutton('rotsubpycode', 'showRotSubPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="rotsubpycode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
def RotWord(word):
    return [word[(i + 1) % 4] for i in range(4)]

def SubWord(word):
    return [SBox[word[i]] for i in range(4)] #SBox is provided in next section</pre>
      </div>
    </div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    <div class="showbar">
      <button type="button" id="showRotSubCBut" onclick="showbutton('rotsubCcode', 'showRotSubCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="rotsubCcode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
static void RotWord(char* word) {
     // assume that word is a char array of length 4
     char temp = word[0];
     word[0] = word[1];
     word[1] = word[2];
     word[2] = word[3];
     word[3] = temp;
}
static void SubWord(char* word) {
     // SBox is provided in next section
     word[0] = SBox[word[0]];
     word[1] = SBox[word[1]];
     word[2] = SBox[word[2]];
     word[3] = SBox[word[3]];
}</pre>
      </div>
    </div>
   <p>Since the size of data that we wish to encrypt is fixed at 16 bytes (hence the term "block" cipher -- we only encrypt one 16-byte block at a time), we choose to represent this data as a 4x4 matrix of bytes which will be hereafter referred to as the <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Our data / plaintext represented as a matrix of bytes for ease of linear transformations">state</a>:
   $$\begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_1 & p_5 & p_9 & p_{13} \\\\ p_2 & p_6 & p_{10} & p_{14} \\\\ p_3 & p_7 & p_{11} & p_{15} \end{pmatrix}$$
   we use the variable \(p_i \) for \( 0 \leq i \leq 15 \) to denote splitting of plaintext into bytes. Our goal is to add a 4 round keys to the state each round (since a round key is only a word and the state is 4 words). In order to do this, we tend to think of the state as an array of 4 columns, and perform such operations column by column. Now the first four round keys are simply the key itself; however, all subsequent round keys are added to the previous 4 round keys after they have passed through the subroutines above. Note that the first 4 round keys are used for <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The process of adding round keys before and after the encryption to expand the possible key space">key-whitening</a>, so we actually have one additional round key which is used for the last round. Thus, for AES-128, there need to be 4 round keys for each of 10 + 1 rounds; for AES-192, there need to be 4 keys for each of 12 + 1 rounds; and for AES-256, there need to be 4 keys for each of 14 + 1 rounds. I am somewhat confident you can do the math. Heres an example of the full key schedule:
  </p>
  <div class="showbar">
    <button type="button" id="showKeyPyBut" onclick="showbutton('keyPycode', 'showKeyPyBut', 'Python')" class="btn btn-dark">Show Python</button>
    <div id="keyPycode" style="display: none; text-align: left;">
       <pre class="prettyprint linenums">
def KeySchedule(key, nRounds):
    # The first round key is the key itself
    for i in range(16):
        RoundKey[i] = key[i]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    for i in range(4, 4*(nRounds + 1)):
        tempWord = [RoundKey[4 * (i - 1) + j] for j in range(4)]
        
        # since the state is 4x the size of a RoundKey, we only apply our
        # subroutines on necessary rounds
        if (i % 4 == 0):
           tempWord = RotWord(tempWord)
           tempWord = SubWord(tempWord)
           tempWord[0] ^= Rcon[i // 4]
        
        # set current round key
        for j in range(4):
            RoundKey[4*i + j] = RoundKey[4*(i-4) + j] ^ tempWord[j]</pre>
    </div>
  </div>
  <div class="showbar">
    <button type="button" id="showKeyCBut" onclick="showbutton('keyCcode', 'showKeyCBut', 'C')" class="btn btn-dark">Show C</button>
    <div id="keyCcode" style="display: none; text-align: left;">
      <pre class="prettyprint linenums">
#define NUM_ROUNDS
                           
static void KeySchedule(const char * key) {
  
    char i;
    char tempWord[4];
    
    // The first round key is the key itself.
    for (i = 0; i < 4; ++i)
    {
        RoundKey[4 * i] = Key[4 * i];
        RoundKey[4 * i + 1] = Key[4 * i + 1];
        RoundKey[4 * i + 2] = Key[4 * i + 2];
        RoundKey[4 * i + 3] = Key[4 * i + 3];
    }
    // All other round keys are found from the previous round keys.
    for (; i < 4 * (NUM_ROUNDS + 1); ++i)
    {
        // copies previous four round keys into column
        tempWord[0] = RoundKey[4 * (i - 1)];
        tempWord[1] = RoundKey[4 * (i - 1) + 1];
        tempWord[2] = RoundKey[4 * (i - 1) + 2];
        tempWord[3] = RoundKey[4 * (i - 1) + 3];
        
        // since the state is 4x the size of a RoundKey, we only apply our
        // subroutines on necessary rounds            
        if (i % 4 == 0)
        {
            RotWord(tempWord);
            SubWord(tempWord);
            
            tempWord[0] ^= Rcon[i / 4]; // Since Rcon is only one byte, all all other elements of word are XORed with identity
        }

        // set current round key                           
        RoundKey[i * 4] = RoundKey[(i - 4) * 4 ] ^ tempWord[0];
        RoundKey[i * 4 + 1] = RoundKey[(i - 4) * 4 + 1] ^ tempWord[1];
        RoundKey[i * 4 + 2] = RoundKey[(i - 4) * 4 + 2] ^ tempWord[2];
        RoundKey[i * 4 + 3] = RoundKey[(i - 4) * 4 + 3] ^ tempWord[3];
    }
}</pre>
    </div>
  </div>
  <p> Where the round constants denoted above by <code>Rcon</code> are simply the first byte of \(2^{i-1}\) in \(GF(2^8)\). The constants are provided in the array below:
  </p>
    <div class="showbar">
      <button type="button" id="showRconBut" onclick="showbutton('keyRcon', 'showRconBut', 'Rcon')" class="btn btn-dark">Show Rcon</button>
      <div id="keyRcon" style="display: none; text-align: left; padding-left: 15px;">
        <code><br>
        {<br>
        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a <br>
        }
        </code>
      </div>
    </div>
    <br>
    <h5 id="item-3-2"><code>SubBytes()</code></h5>
    <p>The first item on our list of round functions is that pesky "substitution" part of our whole substitution-permutation network. The reason our substitution layer is so important is that it provides a non-linear system in \(GF(2^8)\), so that cryptanalsis cannot reduce the cipher to a linear system of equations (which would allow the cipher to be easily broken using GPUs and a sufficient knowledge of finite field arithmetic). Now let \( b \) be an arbitrary byte from our state above (i.e. \( b = p_i \) for some \( 0 \leq i \leq 15\) ) and let \( b_j \) denote the \( j^{th}\) bit for \( 0 \leq j \leq 7 \). The transformation the Substitution layer is applying to \(b\) is
             $$ \tilde{b_i} = b^{-1}_i \oplus b^{-1}_{(i + 4)\mathrm{mod} 8} \oplus b^{-1}_{(i + 5)\mathrm{mod} 8} \oplus b^{-1}_{(i + 6)\mathrm{mod} 8} \oplus b^{-1}_{(i + 7)\mathrm{mod} 8} + c_i $$
         where \(c_i\) denotes the \(i^{th}\) bit of the fixed constant \( 01100011\). Note that the symbols \(\oplus \) here represent addition in \(GF(2^8)\) which <em>just so happens</em> to be the exclusive or <code>XOR</code> operation (i.e. \(0 \oplus 0 = 1 \oplus 1 = 0 \) and \(1 \oplus 0 = 0 \oplus 1 = 1 \) ).
    </p>
    <p> Now if we decided to apply that information bit by bit to a 128-bit state, we would be wasting a <b>YUGE</b> amount of computing power since inversion in \(GF(2^8)\) is incredibly taxing in terms of clock cycles; instead, the National Institute of Standards and Technology (NIST) was gracious enough to provide a precomputed <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="An array contains precomputed solutions to a given byte at the index of that byte; a finite mapping">lookup-table</a>:
    </p>
    <div class="showbar">
      <button type="button" id="showSubBoxBut" onclick="showbutton('subbox', 'showSubBoxBut', 'SBox')" class="btn btn-dark">Show SBox</button>
      <div id="subbox" style="display: none; text-align: left; padding-left: 15px;">
        <code>
      { <br>
      0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, <br>
      0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, <br>
      0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, <br>
      0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, <br>
      0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, <br>
      0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, <br>
      0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, <br>
      0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, <br>
      0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, <br>
      0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, <br>
      0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, <br>
      0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, <br>
      0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, <br>
      0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, <br>
      0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, <br>
      0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 <br>
      }
        </code>
      </div>
    </div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    <p> Now that we have that, creating a function to send the state through the substitution layer is pretty simple:
    </p>
    <div class="showbar">
      <button type="button" id="showSubPyBut" onclick="showbutton('subpycode','showSubPyBut','Python')" class="btn btn-dark">Show Python</button>
      <div id="subpycode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
def SubBytes():
    global state
    state = [[SBox[state[row][col]] for col in range(4)] for row in range(4)] # SBox is array above</pre>
      </div>
    </div>

    <div class="showbar">
    <button type="button" id="showSubCBut" onclick="showbutton('subCcode', 'showSubCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="subCcode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
static void SubBytes() {
    char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] = SBox[(*state)[row][col]]; // SBox is array above
}</pre>
      </div>
    </div>
    <br>
    <h5 id="item-3-3"><code>ShiftRows()</code></h5>
    <p> Next on our agenda is the <code>ShiftRows()</code> method, which basically does just what it sounds like if you're still picturing the state as a \(4 \times 4\) matrix of bytes. Using zero indexed origin (i.e. for \(0 \leq i \leq 3\)), we cyclically shift each row in the state over by \(i\) bytes:
    $$ \begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_1 & p_5 & p_9 & p_{13} \\\\ p_2 & p_6 & p_{10} & p_{14} \\\\ p_3 & p_7 & p_{11} & p_{15} \end{pmatrix} \longmapsto_{ShiftRows()} \begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_5 & p_9 & p_{13} & p_1 \\\\ p_{10} & p_{14} & p_2 & p_6 \\\\ p_{15} & p_{3} & p_{7} & p_{11} \end{pmatrix}  $$
    </p>
    <div class="showbar">
      <button type="button" id="showShiftPyBut" onclick="showbutton('shiftpycode', 'showShiftPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="shiftpycode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
def ShiftRows():
    global state
    for i in range(1, 4):
        state[0][i], state[1][i], state[2][i], state[3][i] = \
        state[i][i], state[(i + 1) % 4][i], state[(i + 2) % 4][i], state[i - 1][i]</pre>
      </div>
    </div>

    <div class="showbar">
      <button type="button" id="showShiftCBut" onclick="showbutton('shiftCcode', 'showShiftCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="shiftCcode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
static void ShiftRows() {
    char temp;

    // Rotate first row 1 columns to left
    temp           = (*state)[0][1];
    (*state)[0][1] = (*state)[1][1];
    (*state)[1][1] = (*state)[2][1];
    (*state)[2][1] = (*state)[3][1];
    (*state)[3][1] = temp;

    // Rotate second row 2 columns to left
    temp           = (*state)[0][2];
    (*state)[0][2] = (*state)[2][2];
    (*state)[2][2] = temp;
    temp       = (*state)[1][2];
    (*state)[1][2] = (*state)[3][2];
    (*state)[3][2] = temp;

    // Rotate third row 3 columns to left
    temp       = (*state)[0][3];
    (*state)[0][3] = (*state)[3][3];
    (*state)[3][3] = (*state)[2][3];
    (*state)[2][3] = (*state)[1][3];
    (*state)[1][3] = temp;
}</pre>
      </div>
    </div>
    <br>
    <h5 id="item-3-4"><code>MixColumns()</code></h5>
    <p> Third is our <code>MixColumns()</code> function, and this is where things start to get trickier. The reason things get tricky is because this function is essentially an affine (linear) transform over \(GF(2^8)\), and is thus heavily dependent on polynomial multiplication. I briefly mentioned in the <code>SubBytes()</code> section that inversion (i.e. division, inverse multiplication) in a Galois field is very computationally taxing -- that basically applies the same to multiplication, except you don't have to go looking for a pair of numbers that satisfy the outcome. Let \(a(x)\) denote the polynomial
        $$ a(x) = 3x^3 + x^2 + x + 2 $$
        with all coefficients in \(GF(2^8)\) and \(s(x)\) the state; then our <code>MixColumns()</code> function is actually just returning \( a(x) \otimes s(x) \).
        As I just mentioned, it is absolutely not that easy. For the Advanced Encryption Standard's irreducible polynomial \( x^4 + 1\), this gives us the transform
        
        $$ \begin{pmatrix} 02 & 03 & 01 & 01 \\\\ 01 & 02 & 03 & 01 \\\\ 01 & 01 & 02 & 03 \\\\ 03 & 01 & 01 & 02 \end{pmatrix} \begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_1 & p_5 & p_9 & p_{13} \\\\ p_2 & p_6 & p_{10} & p_{14} \\\\ p_3 & p_7 & p_{11} & p_{15} \end{pmatrix} $$
        
        If you're interested in why multiplication with respect to the above irreducible polynomial results in this sort of cyclic <code>ShiftRows()</code> behavior that we saw previously, feel free to read up on <a class="popLink" href="https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf">this</a>. It's not super complicated but it's a good 15 minutes worth of calculations, assuming you're familiar with finite field arithmetic.
    </p>
    <p> So going forward, we basically have two options here: since multiplication isn't <em>as</em> hard as division in \(GF(2^8)\), we could formulate a solution for how to brute-force multiply by small numbers; alternatively, we could just do what we did before with the substituion layer and precompute everything into an array. Since this is the coolest damn website you've ever stumbled upon (in the last 15 minutes), I'll go ahead and show both. For the brute-force multiplication, I stumbled on a trick a few years ago that works on numbers under 0x15 (which is all we need since that covers 15 round keys):
    <div class="showbar">
      <button type="button" id="showMultPyBut" onclick="showbutton('multpycode', 'showMultPyBut', 'Python')" class="btn btn-dark">Show Python</button>
        <div id="multpycode" style="display: none; text-align: left;">
          <pre class="prettyprint linenums">
def xtime(x):
    return (x << 1) ^ (((x >> 7) & 0x01) * 0x1b)
        
def gmult(x, y):
    result = (y & 0x01) * x
    result ^= (y>>1 & 1) * xtime(x)
    result ^= (y>>2 & 1) * xtime(xtime(x))
    result ^= (y>>3 & 1) * xtime(xtime(xtime(x)))
    result ^= (y>>4 & 1) * xtime(xtime(xtime(xtime(x))))
    return result & 0xff    #calculations sometimes have an overflow bit</pre>
      </div>
    </div>
    
    <div class="showbar">
      <button type="button" id="showMultCBut" onclick="showbutton('multCcode', 'showMultCBut', 'C')" class="btn btn-dark">Show C</button>
        <div id="multCcode" style="display: none; text-align: left;">
          <pre class="prettyprint linenums">
static char xtime(char x)
{
    return ((x<<1) ^ (((x>>7) & 1) * 0x1b)); // 0x1b represents polynomial x^4 + x^3 + x + 1
}

#define gmult(x, y)                          \
(  ((y & 1) * x) ^                              \
((y>>1 & 1) * xtime(x)) ^                       \
((y>>2 & 1) * xtime(xtime(x))) ^                \
((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))) & 0xff)   \ </pre>
      </div>
    </div>

    <p> Alternatively, we could simply precompute everything and store the results in lookup-table for each number we anticipate multiplying by. Normally this would mean we have numerous large arrays, but luckily the linear transform is only comprised of 0x01, 0x02 and 0x03, the first of which clearly requires no computation.
    </p>
    <p> Multiplication by 0x02: </p>
    <div class="showbar">
      <button type="button" id="showMult2BoxBut" onclick="showbutton('mult2box','showMult2BoxBut', 'Mult2')" class="btn btn-dark">Show Mult2</button>
        <div id="mult2box" style="display: none; text-align: left; padding-left: 15px;">
          <code>
                { <br>
                0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e, <br>
                0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e, <br>
                0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e, <br>
                0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e, <br>
                0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e, <br>
                0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe, <br>
                0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde, <br>
                0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe, <br>
                0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05, <br>
                0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25, <br>
                0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45, <br>
                0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65, <br>
                0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85, <br>
                0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5, <br>
                0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5, <br>
                0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5<br>
                }
        </code>
      </div>
    </div>
    
    <p> Multiplication by 0x03: </p>
    <div class="showbar">
      <button type="button" id="showMult3BoxBut" onclick="showbutton('mult3box', 'showMult3BoxBut', 'Mult3')" class="btn btn-dark">Show Mult3</button>
        <div id="mult3box" style="display: none; text-align: left; padding-left: 15px;">
          <code>
                { <br>
                0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,<br>
                0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,<br>
                0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,<br>
                0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,<br>
                0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,<br>
                0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,<br>
                0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,<br>
                0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,<br>
                0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,<br>
                0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,<br>
                0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,<br>
                0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,<br>
                0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,<br>
                0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,<br>
                0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,<br>
                0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a<br>
                }
        </code>
      </div>
    </div>
    <p> With Galois field multiplication now in our arsenal, the implementation of <code>MixColumns()</code> is now fairly straightforward; however, due to the nature of matrix multiplication, there is the drawback for Python developers that there is no easy condensed, inline-trick to reduce the amount of code. Regardless, what we have is:
    </p>
    <div class="showbar">
      <button type="button" id="showMixPyBut" onclick="showbutton('mixpycode', 'showMixPyBut', 'Python')" class="btn btn-dark">Show Python</button>
        <div id="mixpycode" style="display: none; text-align: left;">
          <pre class="prettyprint linenums">
def MixColumns():
    global state
    for col in range(4):
        # temporary variables
        a = state[col][0]
        b = state[col][1]
        c = state[col][2]
        d = state[col][3]
        
        state[col][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d
        state[col][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d
        state[col][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3)
        state[col][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2)</pre>
      </div>
    </div>
    <div class="showbar">
      <button type="button" id="showMixCBut" onclick="showbutton('mixCcode', 'showMixCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="mixCcode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
static void MixColumns() {
    char a,b,c,d, i;
    for (i = 0; i < 4; i++)
    {
        a = (*state)[i][0];
        b = (*state)[i][1];
        c = (*state)[i][2];
        d = (*state)[i][3];
    
        (*state)[i][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d;
        (*state)[i][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d;
        (*state)[i][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3);
        (*state)[i][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2);
    }
}</pre>
      </div>
    </div>
    <br>
    <h5 id="item-3-5"><code>AddRoundKey()</code></h5>
    <p>It's literally just what it sounds like. If you didn't feel like reading over the <a class="popLink" href="#item-3-1">Key Schedule</a> section but actually want to understand why this is vital to the cipher, then kick rocks, kid, cus that's pretty important. Alright so we understand that there are 4 times as many round keys (plus 4 used for key whitening) as there are rounds; again, this is because the state is 4 times the size of the round key, so in reality we have a full 128-bit round key for each round. If you read the <a class="popLink" href="#item-3-2">SubBytes</a> section, you should also be aware that addition in \(GF(2^8)\) is the same as bitwise exclusive-or (XOR), so you really shouldn't need much help implementing this (but I'm a magnanimous person so here it is):
    </p>
    <div class="showbar">
      <button type="button" id="showAddRoPyBut" onclick="showbutton('addropycode', 'showAddRoPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="addropycode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
def AddRoundKey(round):
    global state
    state = [[state[row][col] ^ RoundKey[16 * round + 4 * row + col] for col in range(4)] for row in range(4)]</pre>
      </div>
    </div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
    <div class="showbar">
      <button type="button" id="showAddRoCBut" onclick="showbutton('addroCcode', 'showAddRoCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="addroCcode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
static void AddRoundKey(uint8_t round)
{
    char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] ^= RoundKey[16 * round  + 4 * row + col]; // Adds RoundKey byte by byte to the state
}</pre>
      </div>
    </div>
    <br>
    <h4 id="item-4">Encryption Code</h4>
    <br>
    <p> Now that we have the main components of AES down, we're ready to put it all together in a clear, continuous block. First, however, recall that the number of rounds is dependent on the key length: for AES-128, there's a total of 10 rounds; for AES-192, there's a total of 12 rounds; and lastly for AES-256, there's a total of 14 rounds.
        For all variants of AES, we perform what is what is called <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The process of adding round keys before and after the encryption to expand the possible key space">key-whitening</a> on the state, such that the <code>AddRoundKey()</code> function applies our key to the initial data. Following that we perform exactly one less than the total number of rounds in the following format:
    </p>
    <div class="showbar">
      <div style="text-align: left; padding-left: 15px;">
        <code>
        <br>
        SubBytes()<br>
        ShiftRows()<br>
        MixColumns()<br>
        AddRoundKey(round)<br>
        <br>
        </code>
      </div>
    </div>
    <p> In the last round, we merely take out the <code>MixColumns()</code> function -- and that's it! That's the AES block cipher. Welp, I hope you enjoyed and understood the majority of it. I will provide the additional content on Galois fields below and a much briefer section on decryption; but if your goal was to understand the most popular cipher in the world currently, this is effectively the end. Thanks for reading! &#x1F601
    </p>
    <div class="showbar">
      <button type="button" id="showFullPyBut" onclick="showbutton('fullpycode', 'showFullPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="fullpycode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">

# Precomputed substitution layer
_SBox = [
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
]

__Nr = 10 # AES-128 in this example

# Test data provided from the FIPS AES documentation

_Key = [ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]
_state=[[0x32, 0x43, 0xf6, 0xa8], [0x88, 0x5a, 0x30, 0x8d], [0x31, 0x31, 0x98, 0xa2], [0xe0, 0x37, 0x07, 0x34]]
_RoundKey = [0 for i in range(16 * (__Nr + 1) )]

def RotWord(word):
    """ Inline function which takes a word (4 bytes) and performs a cyclical
    right shift"""
    return [word[(i + 1) % 4] for i in range(4)]

def SubWord(word):
    """ Takes each individual byte from a word and sends it through the 
    substitution layer"""
    return [_SBox[word[i]] for i in range(4)] #SBox is provided in next section

def KeySchedule():
    """ Rijndael key schedule for generating all round keys
    based off the original key"""

    # Since round constants are only used for the key schedule, we
    # keep them local to the method
    Rcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a]

    # The first round key is the key itself
    for i in range(16):
        _RoundKey[i] = _Key[i]

    for i in range(4, 4 * (__Nr + 1)):
        tempWord = [_RoundKey[4 * (i - 1) + j] for j in range(4)]

        # since the state is 4x the size of a RoundKey, we only apply our
        # subroutines on necessary rounds
        if (i % 4 == 0) :
           tempWord = RotWord(tempWord)
           tempWord = SubWord(tempWord)
           tempWord[0] ^= Rcon[i // 4]

        # set current round key
        for j in range(4):
            RoundKey[4*i + j] = RoundKey[4*(i-4) + j] ^ tempWord[j]

def SubBytes():
    """ Force all data in the state matrix through the substitution layer """
    global _state
    _state = [[_SBox[_state[row][col]] for col in range(4)] for row in range(4)] # SBox is array above

def ShiftRows():
    """ Perform a cyclic shift on each row dependent on the depth of the row"""
    global _state
    for i in range(1, 4):
        _state[0][i], _state[1][i], _state[2][i], _state[3][i] = \
        _state[i][i], _state[(i + 1) % 4][i], _state[(i + 2) % 4][i], _state[i - 1][i]

def xtime(x):
    return (x << 1) ^ (((x >> 7) & 0x01) * 0x1b)

def gmult(x, y):
    result = (y & 0x01) * x
    result ^= (y>>1 & 1) * xtime(x)
    result ^= (y>>2 & 1) * xtime(xtime(x))
    result ^= (y>>3 & 1) * xtime(xtime(xtime(x)))
    result ^= (y>>4 & 1) * xtime(xtime(xtime(xtime(x))))
    return result & 0xff   # return only the first byte of the calculation

def MixColumns():
    """ Affine transform in the Rijndael field on the state """
    global _state
    for col in range(4):
        # temporary variables
        a = _state[col][0]
        b = _state[col][1]
        c = _state[col][2]
        d = _state[col][3]

        _state[col][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d
        _state[col][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d
        _state[col][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3)
        _state[col][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2)

def AddRoundKey(round):
    """Adds the round key generated for that specific round to the state""" 
    global _state
    _state = [[_state[row][col] ^ _RoundKey[16 * round + 4 * row + col] for col in range(4)] for row in range(4)]

def AESCipher():
    """ The complete AES forward encryption performed through byte-array calculations """
    
    # key-whitening
    AddRoundKey(0)
    
    for round in range(1, __Nr):
        SubBytes()
        ShiftRows()
        MixColumns()
        AddRoundKey(round)

    # final round
    SubBytes()
    ShiftRows()
    AddRoundKey(__Nr)

from __future__ import print_function
def printState():
    for i in range(4):
        for j in range(4):
            print(format(_state[j][i], '02x'), end=' ')
        print()
    print()

printState()
KeySchedule()
AESCipher()
printState()</pre>
      </div>
    </div>

    <div class="showbar">
      <button type="button" id="showFullCBut" onclick="showbutton('fullCcode', 'showFullCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="fullCcode" style="display: none; text-align: left;">
        <pre class="prettyprint linenums">
#include &lt;stdio.h&gt;

/*****************************************************************************/
/* Function Declarations:                                                    */
/*****************************************************************************/
static void RotWord(unsigned char*);
static void SubWord(unsigned char*);
static void AddRoundKey(unsigned char);
static void SubBytes();
static void ShiftRows();
static unsigned char xtime(unsigned char);
static void MixColumns();
static void AESCipher();
static void KeySchedule();

#define N_ROUNDS 10

typedef unsigned char state_t[4][4];

static state_t* state;
static unsigned char RoundKey[16 * (N_ROUNDS + 1)];
static const unsigned char* Key;

static const unsigned char SBox[256] =   {
    //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };


int main() {
    
    int i;

    const unsigned char* key = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
    unsigned char in[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};
    state = (state_t*) in;    
    Key = key;

    KeySchedule();
    
    printf("0x");
    for (i = 15; i >= 0; --i)
        printf("%02x", in[i]);
    printf("\n");

    AESCipher();
    
    printf("0x");
    for (i = 15; i >= 0; --i)
        printf("%02x", in[i]);
    printf("\n");

    return 1;
}

/**
 * The complete AES forward encryption performed through byte-array calculations
 */
static void AESCipher() {
    
    // Key-whitening
    AddRoundKey(0);

    unsigned char round;
    for (round =  1; round < N_ROUNDS; ++round) {
        SubBytes();
        ShiftRows();
        MixColumns();
        AddRoundKey(round);
    }

    // final round
    SubBytes();
    ShiftRows();
    AddRoundKey(round);
}

/**
 * Function which takes a word (4 bytes) and performs a cyclical right
 * shift
 */
static void RotWord(unsigned char* word) {
     // assume that word is a char array of length 4
     unsigned char temp = word[0];
     word[0] = word[1];
     word[1] = word[2];
     word[2] = word[3];
     word[3] = temp;
}

/**
 * Takes each individual byte from a word and sends it through the 
 * substitution layer
 */
static void SubWord(unsigned char* word) {
     // SBox is provided in next section
     word[0] = SBox[word[0]];
     word[1] = SBox[word[1]];
     word[2] = SBox[word[2]];
     word[3] = SBox[word[3]];
}

/**
 * Rijndael key schedule for generating all round keys based off
 * the original key
 */
static void KeySchedule() {
 
    const unsigned char Rcon[] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a};
    unsigned char i;
    unsigned char tempWord[4];
    
    // The first round key is the key itself.
    for (i = 0; i < 4; ++i)
    {
        RoundKey[4 * i] = Key[4 * i];
        RoundKey[4 * i + 1] = Key[4 * i + 1];
        RoundKey[4 * i + 2] = Key[4 * i + 2];
        RoundKey[4 * i + 3] = Key[4 * i + 3];
    }
    // All other round keys are found from the previous round keys.
    for (; i < 4 * (N_ROUNDS + 1); ++i)
    {
        // copies previous four round keys into column
        tempWord[0] = RoundKey[4 * (i - 1)];
        tempWord[1] = RoundKey[4 * (i - 1) + 1];
        tempWord[2] = RoundKey[4 * (i - 1) + 2];
        tempWord[3] = RoundKey[4 * (i - 1) + 3];
        
        // since the state is 4x the size of a RoundKey, we only apply our
        // subroutines on necessary rounds            
        if (i % 4 == 0)
        {
            RotWord(tempWord);
            SubWord(tempWord);
            
            tempWord[0] ^= Rcon[i / 4]; // Since Rcon is only one byte, all all other elements of word are XORed with identity
        }

        // set current round key                           
        RoundKey[i * 4] = RoundKey[(i - 4) * 4 ] ^ tempWord[0];
        RoundKey[i * 4 + 1] = RoundKey[(i - 4) * 4 + 1] ^ tempWord[1];
        RoundKey[i * 4 + 2] = RoundKey[(i - 4) * 4 + 2] ^ tempWord[2];
        RoundKey[i * 4 + 3] = RoundKey[(i - 4) * 4 + 3] ^ tempWord[3];
    }
}

/**
 * Force all data in the state matrix through the substitution layer
 */
static void SubBytes() {
    unsigned char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] = SBox[(*state)[row][col]]; // SBox is array above
}

/**
 * Performs a cyclic shift on each row dependent on the depth
 * of the row
 */
static void ShiftRows() {
    unsigned char temp;

    // Rotate first row 1 columns to left
    temp           = (*state)[0][1];
    (*state)[0][1] = (*state)[1][1];
    (*state)[1][1] = (*state)[2][1];
    (*state)[2][1] = (*state)[3][1];
    (*state)[3][1] = temp;

    // Rotate second row 2 columns to left
    temp           = (*state)[0][2];
    (*state)[0][2] = (*state)[2][2];
    (*state)[2][2] = temp;
    temp       = (*state)[1][2];
    (*state)[1][2] = (*state)[3][2];
    (*state)[3][2] = temp;

    // Rotate third row 3 columns to left
    temp       = (*state)[0][3];
    (*state)[0][3] = (*state)[3][3];
    (*state)[3][3] = (*state)[2][3];
    (*state)[2][3] = (*state)[1][3];
    (*state)[1][3] = temp;
}

static unsigned char xtime(unsigned char x) {
    return ((x<<1) ^ (((x>>7) & 1) * 0x1b)); // 0x1b represents polynomial x^4 + x^3 + x + 1
}

#define gmult(x, y)                          \
(  ((y & 1) * x) ^                              \
((y>>1 & 1) * xtime(x)) ^                       \
((y>>2 & 1) * xtime(xtime(x))) ^                \
((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))) & 0xff)   \

/**
 * Affine transformation in the Rijndael field on the state
 */
static void MixColumns() {
    unsigned char a,b,c,d, i;
    for (i = 0; i < 4; i++)
    {
        a = (*state)[i][0];
        b = (*state)[i][1];
        c = (*state)[i][2];
        d = (*state)[i][3];
    
        (*state)[i][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d;
        (*state)[i][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d;
        (*state)[i][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3);
        (*state)[i][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2);
    }
}

/**
 * Adds the round key generated for that specific round to the state
 */
static void AddRoundKey(unsigned char round) {
    unsigned char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] ^= RoundKey[16 * round  + 4 * row + col]; // Adds RoundKey byte by byte to the state
}</pre>
      </div>
    </div>
<br>
    <h4 id="item-5">Additional Content: \(GF(2^8)\)</h4>
<br>
<p>Oh it's you again..</p>
<p>Alright, you've made it this far, so there's only a little bit left to understand: what the hell is this \(GF(2^8)\) symbol that I keep on seeing? Well for starters, that is the Galois Field of order 256 -- the largest number an unsigned byte (8 bits, hence the 8) can represent.
But what is a field? For anyone pursuing pure mathematics, you can jump to the next paragraph; but, for everyone else this may be a bit of an abstract concept (trust me, when I was first studying abstract algebra my first though was 'who even uses this shit?' -- apparently the government institute I would later join as a research fellow).
Well imagine you have some set of objects and you want to know if you can do mathematics on those objects in a similar fashion to the way most people do mathematics on numbers. To find this out, you need to be a little more specific: what kind of mathematics do you want to do?</p>
    <ul>
      <li>Addition and subtraction? You want a <a class="popLink" href="https://en.wikipedia.org/wiki/Group_(mathematics)">Group</a></li>
      <li>Multiplication? A <a class="popLink" href="https://en.wikipedia.org/wiki/Ring_(mathematics)">Ring</a></li>
      <li>Multiplication AND Division? You'll need a <a class="popLink" href="https://en.wikipedia.org/wiki/Field_(mathematics)">Field</a> (<b>this is us</b>)</li>
      <li>Integration? <a class="popLink" href="https://en.wikipedia.org/wiki/Measure_space">Measure Space</a></li>
      <li>Differentiation? A (continuously differentiable at least) <a class="popLink" href="https://en.wikipedia.org/wiki/Manifold">Manifold</a></li>
      <li>Fourier Analysis? A <a class="popLink" href="https://en.wikipedia.org/wiki/Hilbert_space">Hilbert Space</a></li>
      <li>Mechanics on a flat Lipschitz hypersurface over \(\mathbb{CP}^n\) for \(n \geq 3\)? <a class="popLink" href="https://arxiv.org/pdf/math/0604112.pdf">Haha ya fuckin right, guy</a></li>
    </ul>
 <p>Okay back on topic, a Galois Field, which is also known as a finite field, is exactly what it sounds like. It is a finite set of objects that supports addition, subtraction, multiplication, and division, where the objects are information that can be represented in a specific format. According to <a class="popLink" href="https://math.stackexchange.com/questions/72856/order-of-finite-fields-is-pn">an important theorem</a>, that specific format is that the Galois fields must be of order \(p^k\) for some prime \(p\) and some positive integer \(k\); however, all is well for the Rijndael field ( \(GF(2^8)\) ) since 2 is prime and 8 is positive.
 </p>
 <p> Now I'm actually not going to explain Galois fields in the context of the Rijndael field \(GF(2^8) \) in this section, but abstractly for some prime \(p\) and positive integer \(k\). Suppose \(a \in GF(2^8) \); then we can represent the element \(a\) base \(p\) as follows:
    $$ a = a_{k-1}p^{k-1} \oplus a_{k-2}p^{k-2} \oplus \dots \oplus a_{1}p \oplus a_0$$
    for coefficients \(a_i \in \{0, 1, \dots, p-1 \} \) for \(0 \leq i \leq k-1  \) (where \( \oplus \) is the binary operation replacing addition in this field). Now lets take a second to see what's going on here: think about binary, specifically a byte in our Rijndael field. Well our byte is some collection of 1s and 0s; but that makes sense, as our prime is two and so our coefficients can only be 0 and 1! Now consider ternary in the Galois field \( GF(3^4) \). Our coefficients now can only be 0, 1, or 2. Assuming our binary operation is just normal addition, how would we translate the element 2102 in \( GF(3^4 \)? Well, going back to the rational above, this is really
    $$ 2\cdot 3^{4-1} + 1 \cdot 3^{4-2} + 0 \cdot 3^{4-3} + 2\cdot3^{4-4} = 65 $$
    And ta-da, 2102 is the representation of 65 in \( GF(3^4) \).
</p>
<p> But why is this any better? Why can't we just represent 65 as 65 and be content with it? Well there are two main points as to why not: the real world answer is that computer architecture historically and currently is not represented that way; a bit is really an electrical charge in a capacitor which is at one of two states (i.e. 0 for low charge, 1 for high charge). The theoretical (and more relevant answer) is what I'm about to explain in the next paragraph: binary operations in the Galois Field are not the same as they are in real Euclidean space. By binary operations, I'm referring to multiplication and addition, but in their modified format.
</p>
<p> I'll go ahead and start off with the easier of the two: addition in \(GF(p^k)\). However, it may be beneficial to first mention that when we add two coefficients, say \(a\) and \(b\), we are actually adding them in the coefficient <em>Group</em> of order \(p\). Because this group is of prime order, by <a class="popLink" href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)">Lagrange's Theorem</a>, it must be cyclic (this is a straightforward proof). Thus, addition of coefficients is much like modular arithmetic. Now, with that said, addition is basically the same as it is normally is: match coefficient (digit) to coefficient (digit) and add the two. For example, let's consider \(GF(5^3) \) and take \( 413 \) and \( 232 \):
</p>
\[  \ \ \ 413 \\
    +232 \\
  \_\_\_\_\_\_ \\
  \ \ \ 140 \]
 <p> At this point you may be telling yourself "that's just objectively wrong, 3 + 2 is 5 not 0"; well, you're right and wrong. Clearly 3 + 2 = 5 in real Euclidean space, but as I mentioned earlier, the addition is like modular arithmetic with respect to our base prime (which is 5). Thus, we are actually evaluating the expression (3 + 2) mod 5, which does happen to be equal to 0.
 </p>
 <p> For the sake of bringing it full circle, I mentioned earlier that addition in \( GF(2^8)\) is equivalent to the exclusive-or (XOR) operation. This is pretty easy to show; recall that XOR works in the following way:
 </p>
 <table id="xortab">
   <tr>
     <th> P </th>
     <th> Q </th>
     <th> P ^ Q </th>
   </tr>
   <tr>
     <td> TRUE(1) </td>
     <td> TRUE(1) </td>
     <td> FALSE(0) </td>
   </tr>
   <tr>
     <td> TRUE(1) </td>
     <td> FALSE(0) </td>
     <td> TRUE(1) </td>
   </tr>
   <tr>
     <td> FALSE(0) </td>
     <td> TRUE(1) </td>
     <td> TRUE(1)) </td>
   </tr>
   <tr>
     <td> FALSE(0) </td>
     <td> FALSE(0) </td>
     <td> FALSE(0) </td>
   </tr>
 </table>
 <br>
 <p> Well whenever our base prime is 2 (i.e. \(GF(2^k)\) ), we have essentially the same behavior due to the fact that all coefficients are either 1 (true) or 0 (false) and \( 1 \oplus 1 = (1 + 1) \text{mod} 2 = 0 \). An even more helpful fact that we build upon in the decryption stage is that addition and subtraction are the same exact operation in \( GF(2^k) \)! Since subtraction is really just the inverse of addition, its answer can be added by associativity to the subtracted term to get the remaining term; however, since our coefficient group is cyclic (i.e. wraps around), we simply seek a number which satisfies the modular addition. In more layman terms, consider the numbers 12 and 34 in \( GF(5^2) \) and suppose we want to find the answer to \( y = 12 \ominus 34 \). Then by associativity, we also have that the answer would satisfy \( y \oplus 34 = 12 \). Remembering that numbers wrap back around when they become too large, we can reverse engineer the solution to be 33 (since \( 3 \oplus 3 = (3 + 3) \text{mod} 5 = 1 \) and \( 3 \oplus 4 = (3 + 4) \text{mod} 5 = 2\) ).
 </p>
 <p> Now comes the hard part: multiplication. Conceptually it's not much different, in that we choose a number called our <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="A non-constant polynomial which cannot be factored">irreducible polynomial</a>, which we use for the same purposes as our coefficient group of allowing the result to wrap back around when it becomes large (the one slight issue is that a finite field of fixed order may have different primitive polynomials which affect computation).
     However, the difficulty is in the fact that our coefficients collectively affect each coefficient of the other number. When we perform regular multiplication, we are only really working with two coefficients; on the other hand, when we multiply two polynomials, each term of the first affects each term of the second (what most middle-schoolers learn as foil). Galois Field multiplications works the exact same as polynomial multiplication, and for that reason many people actually choose to represent information in polynomial format when it comes time for calculations.
</p>
<p> For example, let's consider multiplication in \( GF(3^3) \) with primitive polynomial \(122 = x^2 + 2x + 2 \). Take the numbers 201 and 11 - translating them into polynomials we get \( 2x^2 + 1 \) and \(x + 1\). By the distributive property (or what many people call FOIL)
    $$ (2x^2 + 1)(x + 1) = 2x^3 + 2x^2 + x + 1 $$
    However, this answer is too large for \(GF(2^3)\) so we must take the answer modulo \(x^2 + 2x + 2\) (using polynomial division) to get
    $$ 2x^3 + 2x^2 + x + 1 \text{mod} x^2 + 2x + 2 = x + 2 $$
    (also it is likely going to be more difficult than regular polynomial division for you since you must keep track of when numbers wrap back around) which translates to 12. Thus, we find that in \( GF(3^3) \) with irreducible polynomial \(x^2 + 2x + 2\), the equation \( 201 \otimes 11 = 12 \) holds. Crazy stuff, huh? As you can see, it is much more computationally intensive to do multiplication in \(GF(2^8)\) than it is to do regular multiplication over the integers \(\mathbb{Z}\).
</p>
<p> Just like subtraction, we perform division taking the expression \( y = \frac{a}{b} \) and multiplying both sides by our known \(b\) so we wind up with \( y \otimes b = a \). From there, we iterate over the possible canditdates for \(y\) to find an equation that satisfies \( y \otimes b = a \) and thus the original \( y = \frac{a}{b} \).
    To see why the SBox from <a class="popLink" href="#item-3-2">SubBytes()</a> provides a level of non-linearity, recall that the SBox performs the calculation
    $$ \tilde{b_i} = b^{-1}_i \oplus b^{-1}_{(i + 4)\mathrm{mod} 8} \oplus b^{-1}_{(i + 5)\mathrm{mod} 8} \oplus b^{-1}_{(i + 6)\mathrm{mod} 8} \oplus b^{-1}_{(i + 7)\mathrm{mod} 8} + c_i $$
    in \(GF(2^8)\). After experiencing for yourself how much more complex multiplication is in a finite field and recognizing the fact that division (for the most part) is a trial-by-error process of searching for the answer, it shouldn't be hard to see that Galois Field arithmetic prevents cryptanalysts from representing the cipher as a system of even thousands of linear equations.
</p>

<br>
<h4 id="item-6">Additional Content: Decryption</h4>
<br>
<p> It's likely become evident to you at this point, but for the reader who hasn't put in too much thought: how do you plan to get back your data now that it has gone through a complex encryption? Sure, you have the key, but I never once told you that the cipher above is its own inverse (because it isn't). Building upon earlier analogies, I have given you a way to put your valuables in a safe, but have not told you anything about how to get them out of the safe. I chose to put this section off until the end due to the fact that many of the inverse operations in AES' <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The process of converting encrypted ciphertext back into its original plaintext">decryption</a> require knowledge of \( GF(2^8) \) from the previous section.
</p>
<h5><code>InvSubBytes()</code></h5>
<p> Going in the same order as encryption, the first routine that we wish to find an inverse for is <code>SubBytes()</code>. If you recall, the non-linearity of the SBox came from the transformation:
$$ \tilde{b_i} = b^{-1}_i \oplus b^{-1}_{(i + 4)\mathrm{mod} 8} \oplus b^{-1}_{(i + 5)\mathrm{mod} 8} \oplus b^{-1}_{(i + 6)\mathrm{mod} 8} \oplus b^{-1}_{(i + 7)\mathrm{mod} 8} + c_i $$
which can be done iteratively by first applying the inverse in \( GF(2^8)\) and then applying the transformation
$$ \tilde{b_i} = b_i \oplus b_{(i + 4)\mathrm{mod} 8} \oplus b_{(i + 5)\mathrm{mod} 8} \oplus b_{(i + 6)\mathrm{mod} 8} \oplus b_{(i + 7)\mathrm{mod} 8} + c_i $$
We could apply the same affine transformation, and take the inverse of the result; however, note that \(b_{(i + j)\text{mod}8}\) refer to the bits of our original byte (which we are trying to find). To perform this mathematically we would need more information about the original bytes before encryption, thus introducing a painful circular-dependency in decryption.
</p>
<p> Fortunately, we have a giant SBox which stores all the results of our <code>SubBytes()</code> mapping -- and even more fortunate, this SBox has no collisions (i.e. it's injective) and maps to every possible byte value (i.e. it's surjective). For those who have a couple weeks of linear algebra under their belt, it should be clear that an inverse exists. To construct this inverse, just find which output byte is mapped to under which input byte -- it's that simple. But, as before, someone already did the work for you so here's the inverse SBox:
<div class="showbar">
  <button type="button" id="showInvSubBoxBut" onclick="showbutton('invsubbox', 'showInvSubBoxBut', 'InvSBox')" class="btn btn-dark">Show InvSBox</button>
  <div id="invsubbox" style="display: none; text-align: left; padding-left: 15px;">
      <code>
      {   <br>
      0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,<br>
      0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,<br>
      0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,<br>
      0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,<br>
      0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,<br>
      0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,<br>
      0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,<br>
      0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,<br>
      0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,<br>
      0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,<br>
      0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,<br>
      0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,<br>
      0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,<br>
      0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,<br>
      0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,<br>
      0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d<br>
      }
      </code>
  </div>
</div>
</p>
<h5><code>InvShiftRows()</code></h5>
<p> If this one isn't blatantly obvious, recall how our original <code>ShiftRows()</code> simply shifted the first row down cyclically to the left by one, shifted the second row down cyclically to the left by two, etc... well just replace left by right and you're golden.
<div class="showbar">
  <button type="button" id="showInvShiftPyBut" onclick="showbutton('invshiftpycode', 'showInvShiftPyBut', 'Python')" class="btn btn-dark">Show Python</button>
    <div id="invshiftpycode" style="display: none; text-align: left;">
      <pre class="prettyprint linenums">
        def InvShiftRows():
          global state
          for i in range(1, 4):
            state[0][i], state[1][i], state[2][i], state[3][i] = \
            state[i][i], state[i - 1][i], state[(i + 2) % 4][i], state[(i+1)%4][i]</pre>
    </div>
</div>
<div class="showbar">
  <button type="button" id="showShiftCBut" onclick="showbutton('shiftCcode', 'showShiftCBut', 'C')" class="btn btn-dark">Show C</button>
    <div id="shiftCcode" style="display: none; text-align: left;">
      <pre class="prettyprint linenums">
        static void InvShiftRows() {
          char temp;
          // Rotate first row 1 columns to left
          temp           = (*state)[3][1];
          (*state)[3][1] = (*state)[2][1];
          (*state)[2][1] = (*state)[1][1];
          (*state)[1][1] = (*state)[0][1];
          (*state)[0][1] = temp;
                                                                                                                                                                                                                                                                                                 
          // Rotate second row 2 columns to left
          temp           = (*state)[0][2];
          (*state)[0][2] = (*state)[2][2];
          (*state)[2][2] = temp;
          temp           = (*state)[1][2];
          (*state)[1][2] = (*state)[3][2];
          (*state)[3][2] = temp;
                                                                                                                                                                                                                                                                                                 
          // Rotate third row 3 columns to left
          temp           = (*state)[1][3];
          (*state)[0][3] = (*state)[2][3];
          (*state)[1][3] = (*state)[3][3];
          (*state)[2][3] = (*state)[0][3];
          (*state)[3][3] = temp;
        }</pre>
    </div>
</div>
                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                 
  </div>
</div>

                                                                                                                                                                                                                          

<!-- webpage footer -->
<div class="jumbotron vertical-center footer">
  <h6>All webpages are self-coded using a combination of HTML5, CSS3, Bootstrap4, and JavaScript</h6>
  <h6>No third-party software is used except to host the domain root directory</h6>
</div>

<!-- Bootstrap 4.1 -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
</body>
</html>


