<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <!-- Bootstrap 4.1 -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <!-- actual stylesheet -->
  <link href="aes.css" rel="stylesheet" type="text/css">
  <!-- google fonts -->
  <link href="https://fonts.googleapis.com/css?family=Quattrocento|Aldrich|Special+Elite" rel="stylesheet">
  <!-- jquery -->
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js'></script>
  <!-- MathJax -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML' async></script>
  <!-- My scripts -->
  <script src="../footerscript.js"></script>
  <script src="../tooltip.js"></script>
  <script src="../showbutton.js"></script>
</head>
<body data-spy="scroll" data-target="#contentNav" data-offset="15" style="position: relative;">

<!-- Navigation bar -->


<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-brand" href="#">Chris Dare</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item">
        <a class="nav-link" href="../homepage.html">Home<span class="sr-only">(current)</span></a>
      </li>
      <!-- Blog Dropdown -->
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="../blogpage.html" id="navbarDropdownBlogLink"  aria-haspopup="true" aria-expanded="false">Blog<span class="sr-only">(current)</span></a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdownBlogLink">
          <a class="dropdown-item" href="../blogposts/manifoldsparti.html">Manifolds: Part I</a>
          <a class="dropdown-item" href="#">Post2</a>
        </div>
      </li>
      <!-- Code Dropdown -->
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="../codepage.html" id="navbarDropdownCodeLink" aria-haspopup="true" aria-expanded="false" style="font-family: 'Courier New', Courier;">
          Code
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdownCodeLink">
          <a class="dropdown-item active" href="#" style="font-family: 'Courier New', Courier;">AES</a>
          <a class="dropdown-item" href="#" style="font-family: 'Courier New', Courier;">Code2</a>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="../mymusicpage.html">My Music</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="../photospage.html">Photos</a>
      </li>
    </ul>
  </div>
</nav>

<!-- webpage header -->

<div class="jumbotron vertical-center header">
  <h1 style="font-family:'Special Elite', cursive;">AES</h1>
  <h5 style="font-family:'Special Elite', cursive;">Advanced Encryption Standard (FIPS 197)</h5>
</div>


<div class="row">

  <!-- side navbar -->
  <div class="col-2">
    <nav id="content-nav" class="navbar navbar-light bg-light">
      <nav class="nav nav-pills flex-column">
        <a class="nav-link" href="#item-1">Introduction To Ciphers</a>
        <a class="nav-link" href="#item-2">Why AES?</a>
        <a class="nav-link" href="#item-3">The Cipher</a>
        <nav class="nav nav-pills flex-column">
          <a class="nav-link ml-3 my-1" href="#item-3-1">Key Schedule</a>
          <a class="nav-link ml-3 my-1" href="#item-3-2"><code>SubBytes()</code></a>
          <a class="nav-link ml-3 my-1" href="#item-3-3"><code>ShiftRows()</code></a>
          <a class="nav-link ml-3 my-1" href="#item-3-4"><code>MixColumns()</code></a>
          <a class="nav-link ml-3 my-1" href="#item-3-5"><code>AddRoundKey()</code></a>
        </nav>
        <a class="nav-link" href="#item-4">Encryption Code</a>
        <a class="nav-link" href="#item-5">Additional Content: \(GF(2^8)\)</a>
      </nav>
    </nav>
  </div>

  <!-- content -->
  <div class="col-10">
      <h4 id="item-1">Introduction to Ciphers</h4>
      <p>In today's world there is a massive effort to secure data that we wish private - and for good reason. 
Clearly, things like our social-security number, credit card information, and passwords should be hidden from anyone who could use them maliciously, but seldom do we ask ourselves how this data is <em>actually</em> hidden. 
Clearly the answer is <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Translating data or plain text into a masked cipher text through the use of a cipher">encryption</a>, or else I wouldn't be spending my Tuesday evening writing a post about the U.S. government's current endorsed encryption (and thus most of the commercial industry as well since many government contractors feel no need to write separate software for the public and private sectors).
 For those who don't know what a block <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="An algorithm used to mask data in a covert manner">cipher</a> is, a good analogy would be an old safe: our cipher is the safe itself, our data is whatever valuable you intend to put in the safe, and our key is also called a key (but is really just a big number of our choosing used for calculations).</p>
      <img src="../images/ciphersafe.png" style="width: 1000px; height: auto;">
      <h4 id="item-2">Why AES?</h4>
      <p>Great question. You'd probably need a masters in computer science or mathematics with respect to algebra to get a full answer.
The simple answer is that it remains very resiliant under years of scrutiny without sacrificing much speed. 
Note that this does not mean that it is an efficient cipher (see <a href="#">PRINCE</a>); nonetheless, would you rather keep your money in a national bank that probably takes half-an-hour to withdraw from or in a safe under your bed?</p>
      <p> For those interested in the security aspect, the previous analogy of the safe breaks down when it comes to the motive of the hackers/thieves.
 Just as a thief is interested in the money inside a safe, one would expect that the motive of a hacker is to get the passwords / sensitive information; however, it is truly the motive of a hacker to retrieve the key (this is a bit subjective since I'm interchanging hacker and cryptanalyst a bit loosely -- in reality I think most hackers would be perfectly happy with a few hundred passwords).
Therefore, the objective of a cipher (i.e. our safe) is to make it as hard as possible to retrieve the safe's key. </p>

      <p> Clearly, as all computer information is stored in binary, our key is just a fixed number of bits (either 128, 192, or 256 for AES); thus, for every bit that we add the <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The abstract set / collection  of all possible keys">key space</a> effectively doubles. 
In order to break a cipher, one must find some sort of algorithm which produces a key with greater efficiency than a <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Trying every key possible to match a plaintext (unencrypted) / ciphertext (encrypted) pair">brute-force</a> solution. 
Though I have not gone into the details of AES yet, this is the rational behind adding extra rounds to larger key sizes.
There are essentially no efficient attacks on AES itself (<a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Attacking the underlying hardware or operating system to bypass an algorithm">side-channel attacks</a> are irrelevant) that are a significant improvement over brute-force. 
While there are currently other ciphers just as strong as AES (i.e. Serpent and Twofish), the attention given to AES over the past two decades has allowed for speedups and security updates to patch commonly-known side-channel attacks.
      </p>
      <h4 id="item-3">The Cipher</h4>
      <p>Now that you have all the background that you probably didn't ask for in the first place, it's time to discuss the actual algorithm of AES.
AES is what cryptographers call a <a style="color: #00c624" data-toggle="tooltip" title data-original-title="A cipher who's algorithm is based off translating a fixed number of bits, then swapping the order of the bits">Substitution-Permutation Network</a> (SPN): every round or iteration of the algorithm takes the chunk of data, breaks the data into small chunks that are fed through a substitution box and thereafter swapped around according to some sort of permutation (although AES also applies a <code>MixColumns()</code> transformation which modifies AES from a typical SPN.
 </p>
<p> In order to truly understand what is going on in AES, the reader would first have to become fimiliar with the basics of ring theory and Galois fields (also referred to as finite fields); I will leave a section at the end to cover these things for the reader who spends too much time in front of a computer screen, but in the meantime I will continue with the algorithm. Now as I briefly mentioned in an aside earlier, the AES algorithm is somewhat dependent on the key-length which is either 128 bits, 192 bits, or 256 bits (note, however, that the size of the data we wish to encrypt is fixed at 128 bytes). The reason I say somewhat is because AES is essentially a collection of functions ( <code>SubBytes()</code>, <code>ShiftRows()</code>, <code>MixColumns</code>, and <code>AddRoundKey()</code> ) that are repeatedly executed; each iteration of these functions is referred to as a <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="A single repetition/iteration of an iterative algorithm">round</a>. Each of AES-128, AES-192, and AES-256 execute the same round, however the number of rounds differs for each variant: AES-128 executes 10 rounds, AES-192 executes 12 rounds, and AES-256 executes 14 rounds. Going back to the rational of more rounds for longer keys (if you actually read the last section), the 14 rounds extends the computation time of most <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Decoding encrypted text without the key">crypanalysis</a> just enough so that it takes as long as a brute-force solution. Without further ado, here's a breakdown of the cipher's main components:
</p>
    <br>
    <h5 id="item-3-1">Key Schedule</h5>
    <br>
    <p> So by this time, you're likely wondering how the key acutally fits into the cipher -- is there some sort of lock hidden in the code where the key mysteriously fits in, maybe some hash function that checks authenticity? Nope, not really. As I briefly touched upon earlier, the key is essentially a large number used in arithmetic operations in \(GF(2^8)\); but even that isn't entirely true, as the key itself is only used in the first round for key-whitening. For later operations, the key is actually used to generate what are called <a style="color: #00c624" data-toggle="tooltip" title data-original-title="Word-sized (4 byte) chunks that are generated from the original key in an algorithm called a Key Schedule">round keys</a> in what is called a <a style="color: #00c624" data-toggle="tooltip" title data-original-title="An algorithm almost always independent of the cipher for generating unique round keys for each round">key schudule</a>; many ciphers utilize the concept of a key schedule, as it greatly improves upon the security of a key. For example, if a cryptanalyst were to gain access to one of our round keys through extensive attacks, the strength of our key schedule would determine whether this information is enough to compute the original key (in the case of AES, it does not but allows the cryptanalyst to gain access to other round keys which collectively can accomplish this task).
    </p>
    <p> The AES key schedule is broken down into two subroutines, <code>SubWord()</code> and <code>RotWord</code>, which are added in \(GF(2^8)\) to a round constant. The algorithm makes its so that, depending on the length of the key, the previous round is added to the current round's key so that, as we continue along the key schedule, we experience a similar <a class="popLink" href="https://en.wikipedia.org/wiki/Avalanche_effect">avalanche effect</a> to that of SHA. Implementing the subroutines is incredibly straightforward: <code>RotWord()</code> cyclically rotates the bytes of the current round key (much like a wrap-around right-shift), and <code>SubWord()</code> simply breaks the round key up into individual bytes and sends them through the SBox (which is explained in next section). Here is the code for each:
    </p>
    <div class="showbar">
      <button type="button" id="showRotSubPyBut" onclick="showbutton('rotsubpycode', 'showRotSubPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="rotsubpycode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #b0b747;">
def RotWord(word):
    return [word[(i + 1) % 4] for i in range(4)]

def SubWord(word):
    return [SBox[word[i]] for i in range(4)] #SBox is provided in next section
        </pre>
      </div>
    </div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    <div class="showbar">
      <button type="button" id="showRotSubCBut" onclick="showbutton('rotsubCcode', 'showRotSubCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="rotsubCcode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #00c624;">
static void RotWord(char* word) {
     // assume that word is a char array of length 4
     char temp = word[0];
     word[0] = word[1];
     word[1] = word[2];
     word[2] = word[3];
     word[3] = temp;
}
static void SubWord(char* word) {
     // SBox is provided in next section
     word[0] = SBox[word[0]];
     word[1] = SBox[word[1]];
     word[2] = SBox[word[2]];
     word[3] = SBox[word[3]];
}
        </pre>
      </div>
    </div>
   <p>Since the size of data that we wish to encrypt is fixed at 16 bytes (hence the term "block" cipher -- we only encrypt one 16-byte block at a time), we choose to represent this data as a 4x4 matrix of bytes which will be hereafter referred to as the <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="Our data / plaintext represented as a matrix of bytes for ease of linear transformations">state</a>:
   $$\begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_1 & p_5 & p_9 & p_{13} \\\\ p_2 & p_6 & p_{10} & p_{14} \\\\ p_3 & p_7 & p_{11} & p_{15} \end{pmatrix}$$
   we use the variable \(p_i \) for \( 0 \leq i \leq 15 \) to denote splitting of plaintext into bytes. Our goal is to add a 4 round keys to the state each round (since a round key is only a word and the state is 4 words). In order to do this, we tend to think of the state as an array of 4 columns, and perform such operations column by column. Now the first four round keys are simply the key itself; however, all subsequent round keys are added to the previous 4 round keys after they have passed through the subroutines above. Note that the first 4 round keys are used for key-whitening, so we actually have one additional round key which is used for the last round. Thus, for AES-128, there need to be 4 round keys for each of 10 + 1 rounds; for AES-192, there need to be 4 keys for each of 12 + 1 rounds; and for AES-256, there need to be 4 keys for each of 14 + 1 rounds. I am somewhat confident you can do the math. Heres an example of the full key schedule:
  </p>
  <div class="showbar">
    <button type="button" id="showKeyPyBut" onclick="showbutton('keyPycode', 'showKeyPyBut', 'Python')" class="btn btn-dark">Show Python</button>
    <div id="keyPycode" style="display: none; text-align: left; padding-left: 15px;">
       <pre style="color: #b0b747;">
def KeySchedule(key, nRounds):
    # The first round key is the key itself
    for i in range(16):
        RoundKey[i] = key[i]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    for i in range(4, 4*(nRounds + 1)):
        tempWord = [RoundKey[4 * (i - 1) + j] for j in range(4)]
        
        # since the state is 4x the size of a RoundKey, we only apply our
        # subroutines on necessary rounds
        if (i % 4 == 0):
           tempWord = RotWord(tempWord)
           tempWord = SubWord(tempWord)
           tempWord[0] ^= Rcon[i // 4]
        
        # set current round key
        for j in range(4):
            RoundKey[4*i + j] = RoundKey[4*(i-4) + j] ^ tempWord[j]                           
       </pre>
    </div>
  </div>
  <div class="showbar">
    <button type="button" id="showKeyCBut" onclick="showbutton('keyCcode', 'showKeyCBut', 'C')" class="btn btn-dark">Show C</button>
    <div id="keyCcode" style="display: none; text-align: left; padding-left: 15px;">
      <pre style="color: #00c624;">
#define NUM_ROUNDS
                           
static void KeySchedule(const char * key) {
  
    char i;
    char tempWord[4];
    
    // The first round key is the key itself.
    for (i = 0; i < 4; ++i)
    {
        RoundKey[4 * i] = Key[4 * i];
        RoundKey[4 * i + 1] = Key[4 * i + 1];
        RoundKey[4 * i + 2] = Key[4 * i + 2];
        RoundKey[4 * i + 3] = Key[4 * i + 3];
    }
    // All other round keys are found from the previous round keys.
    for (; i < 4 * (NUM_ROUNDS + 1); ++i)
    {
        // copies previous four round keys into column
        tempWord[0] = RoundKey[4 * (i - 1)];
        tempWord[1] = RoundKey[4 * (i - 1) + 1];
        tempWord[2] = RoundKey[4 * (i - 1) + 2];
        tempWord[3] = RoundKey[4 * (i - 1) + 3];
        
        // since the state is 4x the size of a RoundKey, we only apply our
        // subroutines on necessary rounds            
        if (i % 4 == 0)
        {
            RotWord(tempWord);
            SubWord(tempWord);
            
            tempWord[0] ^= Rcon[i / 4]; // Since Rcon is only one byte, all all other elements of word are XORed with identity
        }

        // set current round key                           
        RoundKey[i * 4] = RoundKey[(i - 4) * 4 ] ^ tempWord[0];
        RoundKey[i * 4 + 1] = RoundKey[(i - 4) * 4 + 1] ^ tempWord[1];
        RoundKey[i * 4 + 2] = RoundKey[(i - 4) * 4 + 2] ^ tempWord[2];
        RoundKey[i * 4 + 3] = RoundKey[(i - 4) * 4 + 3] ^ tempWord[3];
    }
}
      </pre>
    </div>
  </div>
  <p> Where the round constants denoted above by <code>Rcon</code> are simply the first byte of \(2^{i-1}\) in \(GF(2^8)\). The constants are provided in the array below:
  </p>
    <div class="showbar">
      <button type="button" id="showRconBut" onclick="showbutton('keyRcon', 'showRconBut', 'Rcon')" class="btn btn-dark">Show Rcon</button>
      <div id="keyRcon" style="display: none; text-align: left; padding-left: 15px;">
        <code><br>
        {<br>
        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a <br>
        }
        </code>
      </div>
    </div>
    <h5 id="item-3-2"><code>SubBytes()</code></h5>
    <p>The first item on our list is that pesky "substitution" part of our whole substitution-permutation network. The reason our substitution layer is so important is that it provides a non-linear system in \(GF(2^8)\), so that cryptanalsis cannot reduce the cipher to a linear system of equations (which would allow the cipher to be easily broken using GPUs and a sufficient knowledge of finite field arithmetic). Now let \( b \) be an arbitrary byte from our state above (i.e. \( b = p_i \) for some \( 0 \leq i \leq 15\) ) and let \( b_j \) denote the \( j^{th}\) bit for \( 0 \leq j \leq 7 \). The transformation the Substitution layer is applying to \(b\) is
             $$ \tilde{b_i} = b^{-1}_i \oplus b^{-1}_{(i + 4)\mathrm{mod} 8} \oplus b^{-1}_{(i + 5)\mathrm{mod} 8} \oplus b^{-1}_{(i + 6)\mathrm{mod} 8} \oplus b^{-1}_{(i + 7)\mathrm{mod} 8} + c_i $$
         where \(c_i\) denotes the \(i^{th}\) bit of the fixed constant \( 01100011\). Note that the symbols \(\oplus \) here represent addition in \(GF(2^8)\) which <em>just so happens</em> to be the exclusive or <code>XOR</code> operation (i.e. \(0 \oplus 0 = 1 \oplus 1 = 0 \) and \(1 \oplus 0 = 0 \oplus 1 = 1 \) ).
    </p>
    <p> Now if we decided to apply that information bit by bit to a 128-bit state, we would be wasting a <b>YUGE</b> amount of computing power because inversion in \(GF(2^8)\) is ridiculouly tolling; instead, the National Institute of Standards and Technology (NIST) was gracious enough to provide a precomputed <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="An array contains precomputed solutions to a given byte at the index of that byte; a finite mapping">lookup-table</a>:
    </p>
    <div class="showbar">
      <button type="button" id="showSubBoxBut" onclick="showbutton('subbox', 'showSubBoxBut', 'SBox')" class="btn btn-dark">Show SBox</button>
      <div id="subbox" style="display: none; text-align: left; padding-left: 15px;">
        <code>
      { <br>
      0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, <br>
      0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, <br>
      0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, <br>
      0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, <br>
      0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, <br>
      0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, <br>
      0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, <br>
      0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, <br>
      0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, <br>
      0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, <br>
      0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, <br>
      0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, <br>
      0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, <br>
      0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, <br>
      0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, <br>
      0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 <br>
      }
        </code>
      </div>
    </div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    <p> Now that we have that, creating a function to send the state through the substitution layer is pretty simple:
    </p>
    <div class="showbar">
      <button type="button" id="showSubPyBut" onclick="showbutton('subpycode','showSubPyBut','Python')" class="btn btn-dark">Show Python</button>
      <div id="subpycode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #b0b747;">
def SubBytes():
    global state
    state = [[SBox[state[row][col]] for col in range(4)] for row in range(4)] # SBox is array above
        </pre>
      </div>
    </div>

    <div class="showbar">
    <button type="button" id="showSubCBut" onclick="showbutton('subCcode', 'showSubCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="subCcode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #00c624;">
static void SubBytes() {
    char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] = SBox[(*state)[row][col]]; // SBox is array above
}
        </pre>
      </div>
    </div>
    
    <h5 id="item-3-3"><code>ShiftRows()</code></h5>
    <p> Next on our agenda is the <code>ShiftRows()</code> method, which basically does just what it sounds like if you're still picturing the state as a \(4 \times 4\) matrix of bytes. Using zero indexed origin (i.e. for \(0 \leq i \leq 3\)), we cyclically shift each row in the state over by \(i\) bytes:
    $$ \begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_1 & p_5 & p_9 & p_{13} \\\\ p_2 & p_6 & p_{10} & p_{14} \\\\ p_3 & p_7 & p_{11} & p_{15} \end{pmatrix} \longmapsto_{ShiftRows()} \begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_5 & p_9 & p_{13} & p_1 \\\\ p_{10} & p_{14} & p_2 & p_6 \\\\ p_{15} & p_{3} & p_{7} & p_{11} \end{pmatrix}  $$
    </p>
    <div class="showbar">
      <button type="button" id="showShiftPyBut" onclick="showbutton('shiftpycode', 'showShiftPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="shiftpycode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #b0b747;">
def ShiftRows():
    global state
    for i in range(1, 4):
        state[0][i], state[1][i], state[2][i], state[3][i] = \
        state[i][i], state[(i + 1) % 4][i], state[(i + 2) % 4][i], state[i - 1][i]
        </pre>
      </div>
    </div>

    <div class="showbar">
      <button type="button" id="showShiftCBut" onclick="showbutton('shiftCcode', 'showShiftCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="shiftCcode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #00c624;">
static void ShiftRows() {
    char temp;

    // Rotate first row 1 columns to left
    temp           = (*state)[0][1];
    (*state)[0][1] = (*state)[1][1];
    (*state)[1][1] = (*state)[2][1];
    (*state)[2][1] = (*state)[3][1];
    (*state)[3][1] = temp;

    // Rotate second row 2 columns to left
    temp           = (*state)[0][2];
    (*state)[0][2] = (*state)[2][2];
    (*state)[2][2] = temp;
    temp       = (*state)[1][2];
    (*state)[1][2] = (*state)[3][2];
    (*state)[3][2] = temp;

    // Rotate third row 3 columns to left
    temp       = (*state)[0][3];
    (*state)[0][3] = (*state)[3][3];
    (*state)[3][3] = (*state)[2][3];
    (*state)[2][3] = (*state)[1][3];
    (*state)[1][3] = temp;
}
        </pre>
      </div>
    </div>
    
    <h5 id="item-3-4"><code>MixColumns()</code></h5>
    <p> Third is our <code>MixColumns()</code> function, and this is where things start to get trickier. The reason things get tricky is because this function is essentially an affine (linear) transform over \(GF(2^8)\), and is thus heavily dependent on polynomial multiplication. I briefly mentioned in the <code>SubBytes()</code> section that inversion (i.e. division, inverse multiplication) in a Galois field is very computationally taxing -- that basically applies the same to multiplication, except you don't have to go looking for a pair of numbers that satisfy the outcome. Let \(a(x)\) denote the polynomial
        $$ a(x) = 3x^3 + x^2 + x + 2 $$
        with all coefficients in \(GF(2^8)\) and \(s(x)\) the state; then our <code>MixColumns()</code> function is actually just returning \( a(x) \otimes s(x) \).
        As I just mentioned, it is absolutely not that easy. For the Advanced Encryption Standard's irreducible polynomial \( x^4 + 1\), this gives us the transform
        
        $$ \begin{pmatrix} 02 & 03 & 01 & 01 \\\\ 01 & 02 & 03 & 01 \\\\ 01 & 01 & 02 & 03 \\\\ 03 & 01 & 01 & 02 \end{pmatrix} \begin{pmatrix} p_0 & p_4 & p_8 & p_{12} \\\\ p_1 & p_5 & p_9 & p_{13} \\\\ p_2 & p_6 & p_{10} & p_{14} \\\\ p_3 & p_7 & p_{11} & p_{15} \end{pmatrix} $$
        
        If you're interested in why multiplication with reduce to the above irreducible polynomial results in this sort of cyclic <code>ShiftRows()</code> behavior that we saw previously, feel free to read up on <a class="popLink" href="https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf">this</a>. It's not super complicated but it's a good 15 minutes worth of calculations, assuming you're familiar with finite field arithmetic.
    </p>
    <p> So going forward, we basically have two options here: since multiplication isn't <em>as</em> hard as division in \(GF(2^8)\), we could formulate a solution for how to brute-force multiply by small numbers; alternatively, we could just do what we did before with the substituion layer and precompute everything into an array. Since this is the coolest damn website you've ever stumbled upon (in the last 15 minutes), I'll go ahead and show both. For the brute-force multiplication, I stumbled on a trick a few years ago that works on numbers under 0x15 (which is quite honestly all we need):
    <div class="showbar">
      <button type="button" id="showMultPyBut" onclick="showbutton('multpycode', 'showMultPyBut', 'Python')" class="btn btn-dark">Show Python</button>
        <div id="multpycode" style="display: none; text-align: left; padding-left: 15px;">
          <pre style="color: #b0b747;">
def xtime(x):
    return (x << 1) ^ (((x >> 7) & 0x01) * 0x1b)
        
def gmult(x, y):
    result = (y & 0x01) * x
    result ^= (y>>1 & 1) * xtime(x)
    result ^= (y>>2 & 1) * xtime(xtime(x))
    result ^= (y>>3 & 1) * xtime(xtime(xtime(x)))
    result ^= (y>>4 & 1) * xtime(xtime(xtime(xtime(x))))
    return result & 0xff    #calculations sometimes have an overflow bit
        </pre>
      </div>
    </div>
    
    <div class="showbar">
      <button type="button" id="showMultCBut" onclick="showbutton('multCcode', 'showMultCBut', 'C')" class="btn btn-dark">Show C</button>
        <div id="multCcode" style="display: none; text-align: left; padding-left: 15px;">
          <pre style="color: #00c624;">

static char xtime(char x)
{
    return ((x<<1) ^ (((x>>7) & 1) * 0x1b)); // 0x1b represents polynomial x^4 + x^3 + x + 1
}

#define gmult(x, y)                          \
(  ((y & 1) * x) ^                              \
((y>>1 & 1) * xtime(x)) ^                       \
((y>>2 & 1) * xtime(xtime(x))) ^                \
((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))) & 0xff)   \
        </pre>
      </div>
    </div>

    <p> Alternatively, we could simply precompute everything and store the results in lookup-table for each number we anticipate multiplying by. Normally this would mean we have numerous large arrays, but luckily the linear transform is only comprised of 0x01, 0x02 and 0x03, the first of which clearly requires no computation.
    </p>
    <p> Multiplication by 0x02: </p>
    <div class="showbar">
      <button type="button" id="showMult2BoxBut" onclick="showbutton('mult2box','showMult2BoxBut', 'Mult2')" class="btn btn-dark">Show Mult2</button>
        <div id="mult2box" style="display: none; text-align: left; padding-left: 15px;">
          <code>
                { <br>
                0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e, <br>
                0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e, <br>
                0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e, <br>
                0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e, <br>
                0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e, <br>
                0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe, <br>
                0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde, <br>
                0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe, <br>
                0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05, <br>
                0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25, <br>
                0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45, <br>
                0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65, <br>
                0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85, <br>
                0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5, <br>
                0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5, <br>
                0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5<br>
                }
        </code>
      </div>
    </div>
    
    <p> Multiplication by 0x03: </p>
    <div class="showbar">
      <button type="button" id="showMult3BoxBut" onclick="showbutton('mult3box', 'showMult3BoxBut', 'Mult3')" class="btn btn-dark">Show Mult3</button>
        <div id="mult3box" style="display: none; text-align: left; padding-left: 15px;">
          <code>
                { <br>
                0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,<br>
                0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,<br>
                0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,<br>
                0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,<br>
                0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,<br>
                0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,<br>
                0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,<br>
                0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,<br>
                0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,<br>
                0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,<br>
                0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,<br>
                0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,<br>
                0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,<br>
                0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,<br>
                0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,<br>
                0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a<br>
                }
        </code>
      </div>
    </div>
    <p> With Galois field multiplication now in our arsenal, the implementation of <code>MixColumns()</code> is now fairly straightforward; however, due to the nature of matrix multiplication, there is the drawback for Python developers that there is no easy condensed, inline-trick to reduce the amount of code. Regardless, what we have is:
    </p>
    <div class="showbar">
      <button type="button" id="showMixPyBut" onclick="showbutton('mixpycode', 'showMixPyBut', 'Python')" class="btn btn-dark">Show Python</button>
        <div id="mixpycode" style="display: none; text-align: left; padding-left: 15px;">
          <pre style="color: #b0b747;">
def MixColumns():
    global state
    for col in range(4):
        # temporary variables
        a = state[col][0]
        b = state[col][1]
        c = state[col][2]
        d = state[col][3]
        
        state[col][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d
        state[col][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d
        state[col][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3)
        state[col][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2)
        </pre>
      </div>
    </div>
    <div class="showbar">
      <button type="button" id="showMixCBut" onclick="showbutton('mixCcode', 'showMixCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="mixCcode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #00c624;">
static void MixColumns() {
    char a,b,c,d, i;
    for (i = 0; i < 4; i++)
    {
        a = (*state)[i][0];
        b = (*state)[i][1];
        c = (*state)[i][2];
        d = (*state)[i][3];
    
        (*state)[i][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d;
        (*state)[i][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d;
        (*state)[i][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3);
        (*state)[i][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2);
    }
}
        </pre>
      </div>
    </div>
   
    <h5 id="item-3-5"><code>AddRoundKey()</code></h5>
    <p>It's literally just what it sounds like. If you didn't feel like reading over the <a class="popLink" href="#item-3-1">Key Schedule</a> section but actually want to understand why this is vital to the cipher, then kick rocks, kid, cus that's pretty important. Alright so we understand that there are 4 times as many round keys (plus 4 used for key whitening) as there are rounds; again, this is because the state is 4 times the size of the round key, so in reality we have a full 128-bit round key for each round. If you read the <a class="popLink" href="#item-3-2">SubBytes</a> section, you should also be aware that addition in \(GF(2^8)\) is the same as bitwise exclusive-or (XOR), so you really shouldn't need much help implementing this (but I'm a magnanimous person so here it is):
    </p>
    <div class="showbar">
      <button type="button" id="showAddRoPyBut" onclick="showbutton('addropycode', 'showAddRoPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="addropycode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #b0b747;">
def AddRoundKey(round):
    global state
    state = [[state[row][col] ^ RoundKey[16 * round + 4 * row + col] for col in range(4)] for row in range(4)]
        </pre>
      </div>
    </div>
    <div class="showbar">
      <button type="button" id="showAddRoCBut" onclick="showbutton('addroCcode', 'showAddRoCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="addroCcode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #00c624;">
static void AddRoundKey(uint8_t round)
{
    char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] ^= RoundKey[16 * round  + 4 * row + col]; // Adds RoundKey byte by byte to the state
}
        </pre>
      </div>
    </div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
    <h4 id="item-4">Encryption Code</h4>
    <p> Now that we have the main components of AES down, we're ready to put it all together in a clear, continuous block. First, however, recall that the number of rounds is dependent on the key length: for AES-128, there's a total of 10 rounds; for AES-192, there's a total of 12 rounds; and lastly for AES-256, there's a total of 14 rounds.
        For all variants of AES, we perform what is what is called <a style="color: #00c624;" data-toggle="tooltip" title data-original-title="The process of adding round keys before and after the encryption to expand the possible key space">key-whitening</a> on the state, such that the <code>AddRoundKey()</code> function applies our key to the initial data. Following that we perform exactly one less than the total number of rounds in the following format:
    </p>
    <div class="showbar">
      <div style="text-align: left; padding-left: 15px;">
        <code>
        <br>
        SubBytes()<br>
        ShiftRows()<br>
        MixColumns()<br>
        AddRoundKey(round)<br>
        <br>
        </code>
      </div>
    </div>
    <p> In the last round, we merely take out the <code>MixColumns()</code> function -- and that's it! That's the AES block cipher. Welp, I hope you enjoyed and understood the majority of it. I will provide the additional content on Galois fields below and a much briefer section on decryption; but if your goal was to understand the most popular cipher in the world currently, this is effectively the end. Thanks for reading! &#x1F601
    </p>
    <div class="showbar">
      <button type="button" id="showFullPyBut" onclick="showbutton('fullpycode', 'showFullPyBut', 'Python')" class="btn btn-dark">Show Python</button>
      <div id="fullpycode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #b0b747;">

# Precomputed substitution layer
_SBox = [
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
]

__Nr = 10 # AES-128 in this example

# Test data provided from the FIPS AES documentation

_Key = [ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c]
_state=[[0x32, 0x43, 0xf6, 0xa8], [0x88, 0x5a, 0x30, 0x8d], [0x31, 0x31, 0x98, 0xa2], [0xe0, 0x37, 0x07, 0x34]]
_RoundKey = [0 for i in range(16 * (__Nr + 1) )]

def RotWord(word):
    """ Inline function which takes a word (4 bytes) and performs a cyclical
    right shift"""
    return [word[(i + 1) % 4] for i in range(4)]

def SubWord(word):
    """ Takes each individual byte from a word and sends it through the 
    substitution layer"""
    return [_SBox[word[i]] for i in range(4)] #SBox is provided in next section

def KeySchedule():
    """ Rijndael key schedule for generating all round keys
    based off the original key"""

    # Since round constants are only used for the key schedule, we
    # keep them local to the method
    Rcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a]

    # The first round key is the key itself
    for i in range(16):
        _RoundKey[i] = _Key[i]

    for i in range(4, 4 * (__Nr + 1)):
        tempWord = [_RoundKey[4 * (i - 1) + j] for j in range(4)]

        # since the state is 4x the size of a RoundKey, we only apply our
        # subroutines on necessary rounds
        if (i % 4 == 0) :
           tempWord = RotWord(tempWord)
           tempWord = SubWord(tempWord)
           tempWord[0] ^= Rcon[i // 4]

        # set current round key
        for j in range(4):
            RoundKey[4*i + j] = RoundKey[4*(i-4) + j] ^ tempWord[j]

def SubBytes():
    """ Force all data in the state matrix through the substitution layer """
    global _state
    _state = [[_SBox[_state[row][col]] for col in range(4)] for row in range(4)] # SBox is array above

def ShiftRows():
    """ Perform a cyclic shift on each row dependent on the depth of the row"""
    global _state
    for i in range(1, 4):
        _state[0][i], _state[1][i], _state[2][i], _state[3][i] = \
        _state[i][i], _state[(i + 1) % 4][i], _state[(i + 2) % 4][i], _state[i - 1][i]

def xtime(x):
    return (x << 1) ^ (((x >> 7) & 0x01) * 0x1b)

def gmult(x, y):
    result = (y & 0x01) * x
    result ^= (y>>1 & 1) * xtime(x)
    result ^= (y>>2 & 1) * xtime(xtime(x))
    result ^= (y>>3 & 1) * xtime(xtime(xtime(x)))
    result ^= (y>>4 & 1) * xtime(xtime(xtime(xtime(x))))
    return result & 0xff   # return only the first byte of the calculation

def MixColumns():
    """ Affine transform in the Rijndael field on the state """
    global _state
    for col in range(4):
        # temporary variables
        a = _state[col][0]
        b = _state[col][1]
        c = _state[col][2]
        d = _state[col][3]

        _state[col][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d
        _state[col][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d
        _state[col][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3)
        _state[col][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2)

def AddRoundKey(round):
    """Adds the round key generated for that specific round to the state""" 
    global _state
    _state = [[_state[row][col] ^ _RoundKey[16 * round + 4 * row + col] for col in range(4)] for row in range(4)]

def AESCipher():
    """ The complete AES forward encryption performed through byte-array calculations """
    
    # key-whitening
    AddRoundKey(0)
    
    for round in range(1, __Nr):
        SubBytes()
        ShiftRows()
        MixColumns()
        AddRoundKey(round)

    # final round
    SubBytes()
    ShiftRows()
    AddRoundKey(__Nr)

from __future__ import print_function
def printState():
    for i in range(4):
        for j in range(4):
            print(format(_state[j][i], '02x'), end=' ')
        print()
    print()

printState()
KeySchedule()
AESCipher()
printState()
        </pre>
      </div>
    </div>

    <div class="showbar">
      <button type="button" id="showFullCBut" onclick="showbutton('fullCcode', 'showFullCBut', 'C')" class="btn btn-dark">Show C</button>
      <div id="fullCcode" style="display: none; text-align: left; padding-left: 15px;">
        <pre style="color: #00c624;">
#include <stdio.h>

/*****************************************************************************/
/* Function Declarations:                                                    */
/*****************************************************************************/
static void RotWord(unsigned char*);
static void SubWord(unsigned char*);
static void AddRoundKey(unsigned char);
static void SubBytes();
static void ShiftRows();
static unsigned char xtime(unsigned char);
static void MixColumns();
static void AESCipher();
static void KeySchedule();

#define N_ROUNDS 10

typedef unsigned char state_t[4][4];

static state_t* state;
static unsigned char RoundKey[16 * (N_ROUNDS + 1)];
static const unsigned char* Key;

static const unsigned char SBox[256] =   {
    //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };


int main() {
    
    int i;

    const unsigned char* key = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
    unsigned char in[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};
    state = (state_t*) in;    
    Key = key;

    KeySchedule();
    
    printf("0x");
    for (i = 15; i >= 0; --i)
        printf("%02x", in[i]);
    printf("\n");

    AESCipher();
    
    printf("0x");
    for (i = 15; i >= 0; --i)
        printf("%02x", in[i]);
    printf("\n");

    return 1;
}

/**
 * The complete AES forward encryption performed through byte-array calculations
 */
static void AESCipher() {
    
    // Key-whitening
    AddRoundKey(0);

    unsigned char round;
    for (round =  1; round < N_ROUNDS; ++round) {
        SubBytes();
        ShiftRows();
        MixColumns();
        AddRoundKey(round);
    }

    // final round
    SubBytes();
    ShiftRows();
    AddRoundKey(round);

}

/**
 * Function which takes a word (4 bytes) and performs a cyclical right
 * shift
 */
static void RotWord(unsigned char* word) {
     // assume that word is a char array of length 4
     unsigned char temp = word[0];
     word[0] = word[1];
     word[1] = word[2];
     word[2] = word[3];
     word[3] = temp;
}

/**
 * Takes each individual byte from a word and sends it through the 
 * substitution layer
 */
static void SubWord(unsigned char* word) {
     // SBox is provided in next section
     word[0] = SBox[word[0]];
     word[1] = SBox[word[1]];
     word[2] = SBox[word[2]];
     word[3] = SBox[word[3]];
}

/**
 * Rijndael key schedule for generating all round keys based off
 * the original key
 */
static void KeySchedule() {
 
    const unsigned char Rcon[] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a};
    unsigned char i;
    unsigned char tempWord[4];
    
    // The first round key is the key itself.
    for (i = 0; i < 4; ++i)
    {
        RoundKey[4 * i] = Key[4 * i];
        RoundKey[4 * i + 1] = Key[4 * i + 1];
        RoundKey[4 * i + 2] = Key[4 * i + 2];
        RoundKey[4 * i + 3] = Key[4 * i + 3];
    }
    // All other round keys are found from the previous round keys.
    for (; i < 4 * (N_ROUNDS + 1); ++i)
    {
        // copies previous four round keys into column
        tempWord[0] = RoundKey[4 * (i - 1)];
        tempWord[1] = RoundKey[4 * (i - 1) + 1];
        tempWord[2] = RoundKey[4 * (i - 1) + 2];
        tempWord[3] = RoundKey[4 * (i - 1) + 3];
        
        // since the state is 4x the size of a RoundKey, we only apply our
        // subroutines on necessary rounds            
        if (i % 4 == 0)
        {
            RotWord(tempWord);
            SubWord(tempWord);
            
            tempWord[0] ^= Rcon[i / 4]; // Since Rcon is only one byte, all all other elements of word are XORed with identity
        }

        // set current round key                           
        RoundKey[i * 4] = RoundKey[(i - 4) * 4 ] ^ tempWord[0];
        RoundKey[i * 4 + 1] = RoundKey[(i - 4) * 4 + 1] ^ tempWord[1];
        RoundKey[i * 4 + 2] = RoundKey[(i - 4) * 4 + 2] ^ tempWord[2];
        RoundKey[i * 4 + 3] = RoundKey[(i - 4) * 4 + 3] ^ tempWord[3];
    }
}

/**
 * Force all data in the state matrix through the substitution layer
 */
static void SubBytes() {
    unsigned char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] = SBox[(*state)[row][col]]; // SBox is array above
}

/**
 * Performs a cyclic shift on each row dependent on the depth
 * of the row
 */
static void ShiftRows() {
    unsigned char temp;

    // Rotate first row 1 columns to left
    temp           = (*state)[0][1];
    (*state)[0][1] = (*state)[1][1];
    (*state)[1][1] = (*state)[2][1];
    (*state)[2][1] = (*state)[3][1];
    (*state)[3][1] = temp;

    // Rotate second row 2 columns to left
    temp           = (*state)[0][2];
    (*state)[0][2] = (*state)[2][2];
    (*state)[2][2] = temp;
    temp       = (*state)[1][2];
    (*state)[1][2] = (*state)[3][2];
    (*state)[3][2] = temp;

    // Rotate third row 3 columns to left
    temp       = (*state)[0][3];
    (*state)[0][3] = (*state)[3][3];
    (*state)[3][3] = (*state)[2][3];
    (*state)[2][3] = (*state)[1][3];
    (*state)[1][3] = temp;
}

static unsigned char xtime(unsigned char x)
{
    return ((x<<1) ^ (((x>>7) & 1) * 0x1b)); // 0x1b represents polynomial x^4 + x^3 + x + 1
}

#define gmult(x, y)                          \
(  ((y & 1) * x) ^                              \
((y>>1 & 1) * xtime(x)) ^                       \
((y>>2 & 1) * xtime(xtime(x))) ^                \
((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))) & 0xff)   \

/**
 * Affine transformation in the Rijndael field on the state
 */
static void MixColumns() {
    unsigned char a,b,c,d, i;
    for (i = 0; i < 4; i++)
    {
        a = (*state)[i][0];
        b = (*state)[i][1];
        c = (*state)[i][2];
        d = (*state)[i][3];
    
        (*state)[i][0] = gmult(a, 2) ^ gmult(b, 3) ^ c ^ d;
        (*state)[i][1] = a ^ gmult(b, 2) ^ gmult(c, 3) ^ d;
        (*state)[i][2] = a ^ b ^ gmult(c, 2) ^ gmult(d, 3);
        (*state)[i][3] = gmult(a, 3) ^ b ^ c ^ gmult(d, 2);
    }
}

/**
 * Adds the round key generated for that specific round to the state
 */
static void AddRoundKey(unsigned char round)
{
    unsigned char row, col;
    for (row = 0; row < 4; row++)
        for (col = 0; col < 4; col++)
            (*state)[row][col] ^= RoundKey[16 * round  + 4 * row + col]; // Adds RoundKey byte by byte to the state
}

        </pre>
      </div>
    </div>

    <h4 id="item-5">Additional Content: \(GF(2^8)\)</h4>


  </div>
</div>

                                                                                                                                                                                                                          

<!-- webpage footer -->
<div class="jumbotron vertical-center footer">
  <h6>All webpages are self-coded using a combination of HTML5, CSS3, Bootstrap4, and JavaScript</h6>
  <h6>No third-party software is used except to host the domain root directory</h6>
</div>

<!-- Bootstrap 4.1 -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
</body>
</html>


